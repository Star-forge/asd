# coding=UTF-8
# -*- coding: UTF-8 -*-

# Необходимо для использования некоторых функций ОС
import os

# Модуль для обработки аргументов, передаваемых при запуске
import sys
import socket

# Функция проверки доступности Tcp-порта. Получает как параметр номер порта, адрес целевого ПК и
# возвращает результат либо удачно, либо нет. Причина неудачной попытки не устанавливается.
def checkTcpPort(port, server="127.0.0.1"):
    # Создается сокет для подключения по Ipv4(Семейство адресов AF_INET) и передачи по TCP(Флаг SOCK_STREAM)
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Через созданный сокет устанавливается соединение с адресом и результат записывается в result,
    # характеризуется тем, что возвращает номер ошибки(исключения-exception)
    # Если предыдущая операция вернула 0, то соединение установлено без проблем,
    # а это значит, что порт целевого ПК открыт для соединений
    return sock.connect_ex((server, port))

# Функция проверки доступности UDP-порта . Получает как параметр номер порта, адрес целевого ПК и
# возвращает результат либо удачно, либо нет. Причина неудачной попытки не устанавливается.
def checkUdpPort(port, server="127.0.0.1"):
    # Создается сокет для подключения по Ipv4(Семейство адресов AF_INET) и передачи по UDP(Флаг SOCK_DGRAM)
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    # Через созданный сокет устанавливается соединение с адресом и результат записывается в result,
    # характеризуется тем, что возвращает номер ошибки(исключения-exception)
    # Если предыдущая операция вернула 0, то соединение установлено без проблем,
    # а это значит, что порт целевого ПК открыт для соединений
    return sock.connect_ex((server, port))


# Функция проверки доступности адреса. Получает как параметр идентификатор(адрес),
# возвращает результат либо удачно, либо нет. Причина неудачной попытки не устанавливается.
def ping_service(addr):
    # вызывает командную строку и передает ей необходимую для выполнения команду(ПИНГ)
    # результат, который возвращается командной строкой, помещается в retcode
    # если возвращён 0, то ответ от адресата не получен и возвращается ложь.
    return os.system("ping -n 1 " + str(addr))


# Функция приводит длинное число байт в "человеческий" вид(легкопонимаемый человеком).
# Получает как параметр число байт, если парамерт не указываается, то подставляется 0
# возвращает результат либо удачно, либо нет. Причина неудачной попытки не устанавливается.
def human_size(bytes=0):
    _bytes = float(bytes)
    # Массив приставок, используется для подстановки в текст при написании числа
    type = ["", "Kilo", "Mega", "Giga", "Tera", "Peta", "Exa", "Zetta", "Yotta"]
    # по-умолчанию приставки нет
    index = 0
    # Каждый раз делим на 1024 и инкрементируем(прибавляем 1) итератор приставки,
    # пока полученное число не будет меньше 1024,
    # а значит не будет выбран конечный класс чисел (например, как: единицы, десятки, сотни и т.д.)
    while (_bytes >= 1024):  # например,допустим 5555 больше 1000(не 1024 чтобы было наглядней),
        _bytes /= 1024  # в первом цикле 5555 делится на 1000, получается 5.555
        index += 1  # и итератор становится равен 1(0+1), но т.к. 5.5 меньше 1000, то второго цикла не будет
        # как только класс найден, то мы округляем число до сотых(после запятой) для удобочитаемости
        # например, число 5,555 становится =5,55
        _bytes = round(_bytes, 2)
    # к полученному числу добавляем, соответствующую приставку и окончание
    # например, в результате получится строка "5,55 KiloBytes", вместо изначальных "5555"
    return str(_bytes) + " " + type[index] + "Bytes"
